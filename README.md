# Terminal Launcher for Containerlab

## Synopsis
Let's get something out in the air right off the bat - Containerlab is awesome!
If you're looking at this repository, I probably don't need to espouse the use cases and benefits of
Containerlab compared to other network emulation platforms. That said, why not? Let's do it!

* Native support for containerized network operating systems (e.g., Arista cEOS, Cisco XRd, Nokia SR Linux)
* Easy sharing of labs (e.g., intrinsic Git integration)
* Lightweight/streamlined deployment model; "lab as code"

However, one annoyance of Containerlab (in its current form) is how it handles connections
to the containerized network devices running inside of labs. Since the management networking is handled
natively using the Docker bridge driver, it means that, by default, only the Containerlab host has access 
to the management IP addresses of the virtualized devices. Currently, Containerlab has no mechanism to map
the management port (e.g., SSH port) of the lab devices to a port on the Containerlab host's IP address via PAT/port forwarding.

This is fine if Containerlab is running directly on your client system (e.g., your laptop), but it becomes a significant
concern if you are trying to run Containerlab on a remote system (e.g., a beefier server with more resources to run more
demanding VM-based devices in labs). In this model, the client doesn't have access to the management IPs of the lab devices
connected to the Docker bridge. As such, how is the client machine supposed to launch an SSH session?

There are two main, recommended approaches:
* Launch an SSH session and obtain a shell on the Containerlab host. Within the remote shell, launch a second SSH session to the lab device.
  * This is the approach used by the SSH button in the Containerlab VS Code extension
* Specify the Containerlab host as an SSH jumphost (e.g., using the SecureCRT firewall option or the `-J` flag in the OpenSSH client) when connecting directly to the IP address/DNS hostname of the lab device

> There are also some deployments that have successfully configured the underlying network to route all management traffic
> for Containerlab-managed lab devices to the Containerlab host using the respective Containerlab management subnet (e.g., 172.20.20.0/24 by default). 
> However, for most deployments/networks, this presents a lot of unnecessary complexity. In most cases, this approach also
> prevents the use of the convenient DNS names generated by Containerlab, as those are directly stored on the hosts file of the Containerlab host.
> Additionally, you may also run into NAT issues with this approach, as Docker will, by default, NAT/masquerade all traffic on this management bridge.

These approaches all require a ton of manual labor, since each SSH session has to be created by hand, more or less.

That's where the terminal launcher for Containerlab comes into play. Could I have thought of a more inventive name? Probably. But, boring name for a boring tool, am I right? :)

## Usage
Using this tool is very simple. There are a few commands to be aware of.

| Command                      | Purpose                                                                                                                                                                                                                                                                                                                                                        |
|------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| retrieve-running-nodes       | Query the Containerlab API and output all **running** nodes as a JSON file                                                                                                                                                                                                                                                                                     |
| parse-inspect-output         | Given a JSON file containing a list of nodes, output a JSON file containing only the running nodes.<br>*Note: You only need to run this command if the JSON file containing the nodes potentially contains stopped/exited nodes.*                                                                                                                              |
| launch [*terminal emulator*] | Given a JSON file containing a list of running nodes, launch terminal sessions to all listed nodes. <br>*Warning: This command will launch all nodes in the file, regardless of whether they are marked as running or not. Make sure the input JSON file has been properly filtered by the `retrieve-running-nodes` or `filter-running-nodes` commands first.* |

### Supported Launch Methods

The following terminal emulators/launch methods are supported:
* SecureCRT (VanDyke Software)
* PuTTY (open source by Simon Tatham)
* MTPuTTY (TTYPlus)
* Native OpenSSH in a terminal (OpenBSD Project)

### Caveats and Limitations:
* At this time, only SSH sessions are supported for connecting to the lab devices.
* When running the `launch securecrt` command on WSL 2, the CLI has a tendency to get messed up. In most cases, you simply need to press Enter a few times to fix this. If that doesn't work, run the `reset` command. You can also just run the utility directly on Windows to avoid this issue.

### Running the Tool

It's recommended that you run this tool inside of a Python virtual environment.

NOTE: It is assumed that lab device passwords are NOT sensitive. They are stored in **PLAIN TEXT** inside of the credentials YAML file. Do NOT use a password that actually matters here!!!